using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace JKToolKit.TemplatePropertyGenerator;

[Generator]
public class TemplatePropertySourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses, static (spc, source) => Execute(source.Left, source.Right, spc));


    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclarationSyntax &&
               classDeclarationSyntax.AttributeLists.Count > 0;
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (var attributeSyntax in attributeListSyntax.Attributes)
            {
                if (IsTemplatePropertyAttribute(attributeSyntax))
                {
                    return classDeclarationSyntax;
                }
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax?> classes, SourceProductionContext context)
    {
        foreach (var classDeclaration in classes.Distinct())
        {
            if (classDeclaration is null) continue;

            var namespaceName = GetNamespace(classDeclaration);
            var className = classDeclaration.Identifier.Text;

            var isPartial = classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));

            if (!isPartial)
            {
                // Show diagnostic
                context.ReportDiagnostic
                (
                    Diagnostic.Create
                    (
                        new DiagnosticDescriptor
                        (
                            id: "TPG001",
                            title: "Class must be static partial",
                            messageFormat: "Class must be static partial",
                            category: "TemplatePropertyGenerator",
                            defaultSeverity: DiagnosticSeverity.Error,
                            isEnabledByDefault: true
                        ),
                        classDeclaration.GetLocation()
                    )
                );
                continue;
            }

            var isStatic = classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword));


            var modifiers = isStatic ? "static partial" : "partial";
            var access = classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword)) ? "public" : "internal";


            var decl = $"{access} {modifiers} class {className}";

            var generatedCode = GenerateClassCode(classDeclaration, className, namespaceName, decl);

            context.AddSource($"{namespaceName}.{className}_Generated.cs", SourceText.From(generatedCode, Encoding.UTF8));
        }
    }


    private static string GenerateClassCode(ClassDeclarationSyntax classDeclaration, string className, string? namespaceName, string decl)
    {
        var sb = new StringBuilder();

        sb.AppendLine($"// <auto-generated />");
        sb.AppendLine("using System;");
        if (namespaceName != null)
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"    {decl}");
        sb.AppendLine("    {");

        foreach (var attributeListSyntax in classDeclaration.AttributeLists)
        {
            foreach (var attributeSyntax in attributeListSyntax.Attributes)
            {
                if (!IsTemplatePropertyAttribute(attributeSyntax))
                {
                    continue;
                }

                var attributeArguments = attributeSyntax.ArgumentList?.Arguments;
                if (attributeArguments == null || attributeArguments.Value.Count != 2)
                {
                    continue;
                }

                var name = attributeArguments.Value[0].Expression.ToString().Trim('"');
                var format = attributeArguments.Value[1].Expression.ToString().Trim('"');

                var formatVariables = FormattableHelpers.GetFormattableVariables(format); // Contains value, value1 ...

                var formatMethodParameters = string.Join(", ", formatVariables.Select(v => $"string {v}"));
                var formatMethodSignature = $"public string Format({formatMethodParameters})";

                var formattableMethodSignature = $"public FormattableString AsFormattable({formatMethodParameters})";


                var classNameFormatted = $"{name}Class";

                sb.AppendLine($"        public static readonly {classNameFormatted} {name} = new();");
                sb.AppendLine();
                sb.AppendLine($"        public class {classNameFormatted}");
                sb.AppendLine("        {");
                sb.AppendLine($"            public string Template => \"{format}\";");
                sb.AppendLine();
                sb.AppendLine($"            internal {classNameFormatted}()");
                sb.AppendLine("            {");
                sb.AppendLine("            }");
                sb.AppendLine();
                sb.AppendLine($"            {formatMethodSignature}");
                sb.AppendLine("            {");
                sb.AppendLine($"                return $\"{format}\";");
                sb.AppendLine("            }");

                sb.AppendLine();
                sb.AppendLine($"            {formattableMethodSignature}");
                sb.AppendLine("            {");
                sb.AppendLine($"                return $\"{format}\";");
                sb.AppendLine("            }");

                sb.AppendLine("        }");
            }
        }

        sb.AppendLine("    }");
        if (namespaceName != null)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static bool IsTemplatePropertyAttribute(AttributeSyntax attributeSyntax)
    {
        var name = attributeSyntax.Name.ToString();
        return string.Equals(name, "TemplatePropertyAttribute", StringComparison.OrdinalIgnoreCase) ||
               string.Equals(name, "TemplateProperty", StringComparison.OrdinalIgnoreCase);
    }

    private static string? GetNamespace(SyntaxNode syntaxNode)
    {
        while (syntaxNode != null)
        {
            if (syntaxNode is BaseNamespaceDeclarationSyntax namespaceDeclaration)
            {
                return namespaceDeclaration.Name.ToString();
            }
            syntaxNode = syntaxNode.Parent;
        }
        return null;
    }
}

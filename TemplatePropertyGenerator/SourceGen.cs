using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace JKToolKit.TemplatePropertyGenerator;

[Generator]
public class TemplatePropertySourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses, static (spc, source) => Execute(source.Left, source.Right, spc));

   
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclarationSyntax &&
               classDeclarationSyntax.AttributeLists.Count > 0;
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (var attributeSyntax in attributeListSyntax.Attributes)
            {
                if (IsTemplatePropertyAttribute(attributeSyntax))
                {
                    return classDeclarationSyntax;
                }
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax?> classes, SourceProductionContext context)
    {
        //EnsureTemplatePropertyAttribute(compilation, context);
        foreach (var classDeclaration in classes.Distinct())
        {
            if (classDeclaration is null) continue;

            var namespaceName = GetNamespace(classDeclaration);
            var className = classDeclaration.Identifier.Text;
            var generatedCode = GenerateClassCode(classDeclaration, className, namespaceName);

            context.AddSource($"{className}_Generated.cs", SourceText.From(generatedCode, Encoding.UTF8));
        }
    }

    //private static void EnsureTemplatePropertyAttribute(Compilation compilation, SourceProductionContext context)
    //{
    //    var attributeSymbol = compilation.GetTypeByMetadataName("TemplatePropertyAttribute");

    //    if (attributeSymbol != null)
    //    {
    //        return;
    //    }

    //    var attributeSource = """
    //        using System;

    //        [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
    //        internal class TemplatePropertyAttribute : Attribute
    //        {
    //            public string Name { get; }
    //            public string Format { get; }

    //            public TemplatePropertyAttribute(string name, string format)
    //            {
    //                Name = name;
    //                Format = format;
    //            }
    //        }
    //        """;

    //    context.AddSource("TemplatePropertyAttribute.g.cs", SourceText.From(attributeSource, Encoding.UTF8));
    //}


    private static string GenerateClassCode(ClassDeclarationSyntax classDeclaration, string className, string? namespaceName)
    {
        var sb = new StringBuilder();

        sb.AppendLine($"// <auto-generated />");
        sb.AppendLine("using System;");
        if (namespaceName != null)
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }
        sb.AppendLine($"    public static partial class {className}");
        sb.AppendLine("    {");

        foreach (var attributeListSyntax in classDeclaration.AttributeLists)
        {
            foreach (var attributeSyntax in attributeListSyntax.Attributes)
            {
                if (!IsTemplatePropertyAttribute(attributeSyntax))
                {
                    continue;
                }

                var attributeArguments = attributeSyntax.ArgumentList?.Arguments;
                if (attributeArguments == null || attributeArguments.Value.Count != 2)
                {
                    continue;
                }

                var name = attributeArguments.Value[0].Expression.ToString().Trim('"');
                var format = attributeArguments.Value[1].Expression.ToString().Trim('"');

                var formatVariables = FormattableHelpers.GetFormattableVariables(format); // Contains value, value1 ...

                var formatMethodParameters = string.Join(", ", formatVariables.Select(v => $"string {v}"));
                var formatMethodSignature = $"public string Format({formatMethodParameters})";

                var formattableMethodSignature = $"public FormattableString AsFormattable({formatMethodParameters})";


                var classNameFormatted = $"{name}Class";

                sb.AppendLine($"        public static readonly {classNameFormatted} {name} = new();");
                sb.AppendLine();
                sb.AppendLine($"        public class {classNameFormatted}");
                sb.AppendLine("        {");
                sb.AppendLine($"            public string Template => \"{format}\";");
                sb.AppendLine();
                sb.AppendLine($"            internal {classNameFormatted}()");
                sb.AppendLine("            {");
                sb.AppendLine("            }");
                sb.AppendLine();
                sb.AppendLine($"            {formatMethodSignature}");
                sb.AppendLine("            {");
                sb.AppendLine($"                return $\"{format}\";");
                sb.AppendLine("            }");

                sb.AppendLine();
                sb.AppendLine($"            {formattableMethodSignature}");
                sb.AppendLine("            {");
                sb.AppendLine($"                return $\"{format}\";");
                sb.AppendLine("            }");

                sb.AppendLine("        }");
            }
        }

        sb.AppendLine("    }");
        if (namespaceName != null)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    

    private static bool IsTemplatePropertyAttribute(AttributeSyntax attributeSyntax)
    {
        var name = attributeSyntax.Name.ToString();
        return string.Equals(name, "TemplatePropertyAttribute", StringComparison.OrdinalIgnoreCase) ||
               string.Equals(name, "TemplateProperty", StringComparison.OrdinalIgnoreCase);
    }

    private static string? GetNamespace(SyntaxNode syntaxNode)
    {
        while (syntaxNode != null)
        {
            if (syntaxNode is BaseNamespaceDeclarationSyntax namespaceDeclaration)
            {
                return namespaceDeclaration.Name.ToString();
            }
            syntaxNode = syntaxNode.Parent;
        }
        return null;
    }
}
